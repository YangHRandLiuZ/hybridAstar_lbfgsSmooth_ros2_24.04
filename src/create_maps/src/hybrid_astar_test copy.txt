/**
 * @file hybrid_astar_test.cpp
 * @author jiaxier
 * @brief ROS 2 port of hybrid A* test node
 * @version 0.1
 * @date 2023-12-23
 */
#include "rclcpp/rclcpp.hpp"
#include <nav_msgs/msg/path.hpp>
#include <geometry_msgs/msg/pose_stamped.hpp>
#include <geometry_msgs/msg/pose_with_covariance_stamped.hpp>
#include <visualization_msgs/msg/marker.hpp>
#include <visualization_msgs/msg/marker_array.hpp>
#include <tf2_ros/buffer.h>
#include <tf2_ros/transform_listener.h>
#include <tf2/utils.h>

#include <grid_map_ros/grid_map_ros.hpp>
#include <grid_map_msgs/msg/grid_map.hpp>
#include <grid_map_core/Polygon.hpp>
#include <grid_map_core/iterators/PolygonIterator.hpp>

#include <ompl/base/spaces/ReedsSheppStateSpace.h>
#include <ompl/geometric/SimpleSetup.h>
#include <ompl/base/ScopedState.h>
#include <boost/program_options.hpp>
#include <ompl/config.h>

#include "hybrid_astar_searcher/calculate_heuristic.h"
#include "hybrid_astar_searcher/hybrid_astar.h"
#include "hybrid_astar_searcher/dynamicvoronoi.h"
#include "hybrid_astar_searcher/smooth.h"

namespace ob = ompl::base;
namespace og = ompl::geometric;
typedef ompl::base::SE2StateSpace::StateType State;
using namespace planning;
using namespace std;
using namespace grid_map;

class HybridAstarNode : public rclcpp::Node {
public:
    HybridAstarNode() : Node("hybrid_astar_test") {
        // 初始化发布者和订阅者（增加目标点话题的可靠性配置）
        map_sub_ = this->create_subscription<grid_map_msgs::msg::GridMap>(
            "/grid_map", 10, 
            std::bind(&HybridAstarNode::Gridmap_Callback, this, std::placeholders::_1)
        );

        marker_pub_ = this->create_publisher<visualization_msgs::msg::Marker>("rs_path_marker", 10);
        start_sub_ = this->create_subscription<geometry_msgs::msg::PoseWithCovarianceStamped>(
            "/initialpose", 10,
            std::bind(&HybridAstarNode::startCallback, this, std::placeholders::_1)
        );
        
        // 目标点订阅者增加回调组，避免阻塞
        auto goal_callback_group = this->create_callback_group(
            rclcpp::CallbackGroupType::MutuallyExclusive
        );
        rclcpp::SubscriptionOptions goal_sub_options;
        goal_sub_options.callback_group = goal_callback_group;
        
        goal_sub_ = this->create_subscription<geometry_msgs::msg::PoseStamped>(
            "/move_base_simple/goal", 10,
            std::bind(&HybridAstarNode::goalCallback, this, std::placeholders::_1),
            goal_sub_options
        );

        path_vis_pub_ = this->create_publisher<nav_msgs::msg::Path>("/path", 10);
        optimized_traj_pub_ = this->create_publisher<nav_msgs::msg::Path>("/optimized_path", 10);
        voronoi_pub_ = this->create_publisher<visualization_msgs::msg::Marker>("voronoi", 10);
        // 增加目标点可视化发布者，用于调试
        goal_vis_pub_ = this->create_publisher<visualization_msgs::msg::Marker>("goal_marker", 10);

        smoother_ptr_ = std::make_unique<Smoother>();
        
        timer_ = this->create_wall_timer(
            std::chrono::milliseconds(100),
            std::bind(&HybridAstarNode::run, this)
        );

        RCLCPP_INFO(this->get_logger(), "Hybrid A* node initialized, waiting for goal on /move_base_simple/goal");
    }

private:
    void Gridmap_Callback(const grid_map_msgs::msg::GridMap::SharedPtr msg) {
        if (gmap_.exists("elevation")) return;
        RCLCPP_INFO(this->get_logger(), "Received map");
        if (!GridMapRosConverter::fromMessage(*msg, gmap_)) {
            RCLCPP_ERROR(this->get_logger(), "Failed to convert grid map message");
            return;
        }
        RCLCPP_INFO(this->get_logger(), "FrameId: %s", gmap_.getFrameId().c_str());
        RCLCPP_INFO(this->get_logger(), "Map size: %f x %f m (%i x %i cells)",
                    gmap_.getLength().x(), gmap_.getLength().y(),
                    gmap_.getSize()(0), gmap_.getSize()(1));

        hybrid_astar_ptr_ = std::make_unique<HybridAstar>(this->shared_from_this(), gmap_);

        // 初始化二进制地图用于Voronoi图
        int size_x = gmap_.getSize()(0);
        int size_y = gmap_.getSize()(1);
        bool** bin_map = new bool*[size_x];
        for (int i = 0; i < size_x; ++i) {
            bin_map[i] = new bool[size_y];
            for (int j = 0; j < size_y; ++j) {
                Vec2d pos;
                pos(0) = -25 + (i + 0.5) * gmap_.getResolution();
                pos(1) = -25 + (j + 0.5) * gmap_.getResolution();
                bin_map[i][j] = (gmap_.atPosition("elevation", pos) > 0);
            }
        }

        voronoiDiagram_.initializeMap(size_x, size_y, bin_map);
    }

    void run() {
        // 增加状态检查日志
        if (!has_start_) {
            RCLCPP_DEBUG(this->get_logger(), "Waiting for start position");
        }
        if (!has_goal_) {
            RCLCPP_DEBUG(this->get_logger(), "Waiting for goal position");
        }

        if (has_start_ && has_goal_) {
            RCLCPP_INFO(this->get_logger(), "Has start and goal, planning...");
            voronoi_pub_->publish(voronoi_);

            auto hybrid_astar_start = std::chrono::high_resolution_clock::now();
            Visualize vis(this->shared_from_this());
            if (hybrid_astar_ptr_ && hybrid_astar_ptr_->plan(start_pose_, goal_pose_, result_)) {
                RCLCPP_INFO(this->get_logger(), "Search success");
                auto hybrid_astar_end = std::chrono::high_resolution_clock::now();
                std::chrono::duration<double> use_time = hybrid_astar_end - hybrid_astar_start;
                RCLCPP_INFO(this->get_logger(), "Hybrid A* time: %.2f ms", use_time.count() * 1000);

                // 路径平滑
                vector<Vec3d> path2smooth;
                for (int i = 0; i < result_.x.size(); ++i) {
                    path2smooth.push_back({result_.x[i], result_.y[i], result_.theta[i]});
                }

                auto smooth_start = std::chrono::high_resolution_clock::now();
                smoother_ptr_->optimize(voronoiDiagram_, path2smooth);
                vector<Vec3d> smooth_path;
                smoother_ptr_->getSmoothPath(smooth_path);
                auto smooth_end = std::chrono::high_resolution_clock::now();
                RCLCPP_INFO(this->get_logger(), "Smoothing time: %.2f ms", 
                           (smooth_end - smooth_start).count() * 1000);

                // 可视化原始路径
                visualization_msgs::msg::Marker marker;
                marker.header.frame_id = "map";
                marker.header.stamp = this->now();
                marker.ns = "rs_path";
                marker.id = 1;
                marker.action = visualization_msgs::msg::Marker::ADD;
                marker.pose.orientation.w = 1.0;
                marker.type = visualization_msgs::msg::Marker::LINE_STRIP;
                marker.scale.x = 0.05;
                marker.color.a = 1.0;
                marker.color.b = 1.0;

                for (size_t i = 0; i < result_.x.size(); ++i) {
                    geometry_msgs::msg::Point point;
                    point.x = result_.x[i];
                    point.y = result_.y[i];
                    point.z = 0.1;
                    marker.points.push_back(point);
                    vis.publishPathPoint({result_.x[i], result_.y[i]}, i);
                    vis.publishVehicleBoxes({smooth_path[i](0), smooth_path[i](1), smooth_path[i](2)}, i);
                }
                marker_pub_->publish(marker);

                // 可视化平滑路径
                visPath(smooth_path);

                // 规划完成后重置状态，允许新的目标点
                has_start_ = false;
                has_goal_ = false;
                RCLCPP_INFO(this->get_logger(), "Planning completed, waiting for new start/goal");
            } else {
                RCLCPP_WARN(this->get_logger(), "Search failed");
            }
        }
    }

    void visPath(const std::vector<Eigen::Vector3d>& path) {
        nav_msgs::msg::Path nav_path;
        nav_path.header.frame_id = "map";
        nav_path.header.stamp = this->now();
        for (const auto& pose : path) {
            geometry_msgs::msg::PoseStamped pos;
            pos.header = nav_path.header;
            pos.pose.position.x = pose[0];
            pos.pose.position.y = pose[1];
            pos.pose.position.z = 0.05;
            nav_path.poses.push_back(pos);
        }
        path_vis_pub_->publish(nav_path);
    }

    void startCallback(const geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr msg) {
        start_pose_[0] = msg->pose.pose.position.x;
        start_pose_[1] = msg->pose.pose.position.y;
        start_pose_[2] = tf2::getYaw(msg->pose.pose.orientation);
        has_start_ = true;
        RCLCPP_INFO(this->get_logger(), "Received start position: (%.2f, %.2f, %.2f)",
                   start_pose_[0], start_pose_[1], start_pose_[2]);
    }

    // 增强目标点回调函数：增加详细日志和可视化
    void goalCallback(const geometry_msgs::msg::PoseStamped::SharedPtr msg) {
        // 检查消息有效性
        if (!msg) {
            RCLCPP_ERROR(this->get_logger(), "Received null goal message");
            return;
        }
        
        // 检查坐标系
        if (msg->header.frame_id.empty() || msg->header.frame_id != "map") {
            RCLCPP_WARN(this->get_logger(), "Goal frame_id is %s (expected 'map'), converting...",
                       msg->header.frame_id.c_str());
            // 这里可以添加坐标系转换逻辑，如果需要的话
        }

        // 解析目标点
        goal_pose_[0] = msg->pose.position.x;
        goal_pose_[1] = msg->pose.position.y;
        goal_pose_[2] = tf2::getYaw(msg->pose.orientation);
        has_goal_ = true;

        // 详细日志输出
        RCLCPP_INFO(this->get_logger(), "Received goal position: (%.2f, %.2f, %.2f) in frame %s",
                   goal_pose_[0], goal_pose_[1], goal_pose_[2],
                   msg->header.frame_id.c_str());

        // 发布目标点可视化标记，用于调试
        publishGoalMarker(msg->pose);
    }

    // 新增：发布目标点可视化标记
    void publishGoalMarker(const geometry_msgs::msg::Pose& goal_pose) {
        visualization_msgs::msg::Marker marker;
        marker.header.frame_id = "map";
        marker.header.stamp = this->now();
        marker.ns = "goal_marker";
        marker.id = 0;
        marker.action = visualization_msgs::msg::Marker::ADD;
        marker.type = visualization_msgs::msg::Marker::SPHERE;
        marker.pose = goal_pose;
        marker.scale.x = 0.3;
        marker.scale.y = 0.3;
        marker.scale.z = 0.3;
        marker.color.r = 1.0;
        marker.color.g = 0.0;
        marker.color.b = 0.0;
        marker.color.a = 0.8;
        goal_vis_pub_->publish(marker);
    }

    // 成员变量
    rclcpp::Subscription<grid_map_msgs::msg::GridMap>::SharedPtr map_sub_;
    rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr marker_pub_;
    rclcpp::Subscription<geometry_msgs::msg::PoseWithCovarianceStamped>::SharedPtr start_sub_;
    rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr goal_sub_;
    rclcpp::Publisher<nav_msgs::msg::Path>::SharedPtr path_vis_pub_;
    rclcpp::Publisher<nav_msgs::msg::Path>::SharedPtr optimized_traj_pub_;
    rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr voronoi_pub_;
    // 新增：目标点可视化发布者
    rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr goal_vis_pub_;
    rclcpp::TimerBase::SharedPtr timer_;

    GridMap gmap_;
    std::unique_ptr<HybridAstar> hybrid_astar_ptr_;
    HybridAstarResult result_;
    DynamicVoronoi voronoiDiagram_;
    std::unique_ptr<Smoother> smoother_ptr_;
    visualization_msgs::msg::Marker voronoi_;

    Vec3d start_pose_, goal_pose_;
    bool has_start_ = false, has_goal_ = false;
};

int main(int argc, char **argv) {
    rclcpp::init(argc, argv);
    auto node = std::make_shared<HybridAstarNode>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}